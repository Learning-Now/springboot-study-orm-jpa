
# 트랜잭션과 락, 2차캐시

- 트랜잭션과 락 : JPA가 제공하는 트랜잭션과 락 기능을 다룬다.
- 2차 캐시 : JPA가 제공하는 애플리케이션 범위의 캐시를 다룬다.

---

## 트랜잭션과 락

트랜잭션은 ACID라는 원자성, 일관성, 격리성, 지속성을 보장해야한다.

- 원자성 : 트랜잭션 내의 작업은 모두 성공해야 하거나 모두 실패해야한다.
- 일관성 : 일관성 있는 데이터베이스 상태를 유지해야한다.
- 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리
- 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과를 항상 기록 해야한다.

이때 트랜잭션은 다른건 문제가 되지 않지만 격리성에서 문제가 발생한다. 트랜잭션간 격리성을 완벽히 보장하려면 트랜잭션을 차례대로 실행해야 하는데 이는 동시성 처리 성능이 매우 나빠진다.

**트랜잭션 격리 수준**

1. READ UNCOMMITTED(커밋되지 않은 읽기)
2. READ COMMITTED(커밋된 읽기)
3. REPEATABLE READ(반복 가능한 읽기)
4. SERIALIZABLE(직렬화)

 

[트랜잭션 격리 수준과 문제점](https://www.notion.so/fa619c1587ec4641b2c917aceb173e82)

**READ UNCOMMITTED** 

커밋 하지 않은 데이터를 읽을 수 있음. 

- 트랜잭션 1이 수정중 커밋하지 않아도 트랜잭션 2가 수정중인 데이터 조회 가능 → DIRTY READ (이때 트랜잭션 1이 롤백을 해버리면 데이터 정합성에 문제 발생)

**READ COMMITTED**

커밋한 데이터만 읽을 수 있다.

- DIRTY READ 발생 하지 않는다.
- 트랜잭션 1이 회원 A 조회중 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회 했을때 수정된 데이터 조회 →  NON-REPEATABLE READ ( 반복해서 같은 데이터를 읽을 수 없는 상태 )

**REPEATABLE READ**

한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회됨.

- 트랜잭션 1이 10살 이하 회원을 조회했을때, 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션 1이 다시 조회했을때 회원이 하나 추가된 상태로 조회 → PHANTOM READ

**SERIALIZABLE**

가장 엄격한 트랜잭션 격리 수준으로 동시성 처리 성능이 급격히 떨어질 우려가 있다.

---

## 낙관적 락과 비관적 락 기초

JPA의 1차 캐시를 적절히 사용 한다면 데이터 베이스 트랜션이 READ COMMITTED 여도 애플리케이션 레벨에서 REPEATABLE READ가 가능하다. 이때 더 높은 수준의 격리를 원한다면 낙관적 락과 비관적 락을 사용하면 된다.

**낙관적 락**은 트랜잭션의 충돌이 발생하지 않는다는 가정하에 쓰이는 방법이다. JPA가 제공하는 버젼 관리 기능을 사용하며 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알수 없다는게 특징이다.

**비관적 락**은 이름 충돌이 발생한다는 가정하에 락을 걸고 보는 방법이다. select for update 구문이 있다.

만약 사용자 A와 B가 동시에 수정중일때 A가 수정완료를 하고 B가 수정완료를 누른다면 B가 수정한 내용만 남게 된다. 이것을 두번의 갱신 분실 문제라 하는데 이를 해결하기 위해서는 3가지 방법이 있다.

1. 마지막 커밋만 인정하기
2. 최초 커밋만 인정하기
3. 충돌하는 갱신 내용 병합하기

### @Version

JPA가 제공하는 낙관적 락을 사용하려면 @Version 어노테이션을 사용해 버젼관리 기능을 추가해야한다.

**적용 가능한 타입**

- Long
- Integer
- Short
- TimeStamp

```java
@Version
private Integer version;
```

엔티티를 수정할때 마다 버젼이 하나씩 자동으로 증가한다. 엔티티 수정시 조회 버전과 수정시점 버전이 다를경우 예외가 발생하게 된다.

### JPA 낙관적 락

JPA가 제공하는 낙관적 락은 @Version을 사용하며 커밋하는 시점에 충돌을 알수 있다는 특징이 있다.

@Version만 있어도 낙관적 락이 적용되며 다음과 같은 옵션이 존재한다.

1. None
2. OPTIMISTIC ( 엔티티를 조회만 하더라도 버전을 체크하며 트랜잭션이 종료할때까지 다른 트랜잭션에서 변경되지 않음을 보장 )
3. OPTIMISTIC_FORCE_INCREMENT ( 엔티티를 묶음으로 관리 가능 )

### JPA 비관적 락

JPA가 제공하는 비관적 락은 데이터 베이스의 트랜잭션 락 메커니즘에 의존하는 방법으로 select for update 구문을 사용하면서 시작하게 된다.