### JPA 표준 예외 정리
JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스다.    
그리고 이 예외 클래스는 RuntimeException의 자식이다.    
따라서 JPA 예외는 모두 언체크 예외다. JPA 표준 예외는 크게 2가지로 나눌 수 있다.


#### 트랜잭션 롤백을 표시하는 예
- javax.persistence.EntityExistsException-> EntityManager.persist(...) 처럼 이미 같은 엔터티가 있으면 발생한다.
- javax.persistence.EntityNoFoundException-? EntityManager.getReference(...)호출할때 실제사용하면 엔터티가 존재하지 않으면 발생한다.
  refresh(...), lock(...)에서도 발생한다.
- javax.persistence.OptimisticLockException-> 낙관적 락 충돌 시 발생한다.
- javax.persistence.PessimisticLockException-> 비관적 락 충돌 시 발생한다.
- javax.persistence.RollbackException-> EntityTrasaction.commit() 실패 시 발생
  롤백이 표시되어 있는 트랜잭션 커밋 시에도 발생한다.
- javax.persistence.TransactionRequiredException-> 트랜잭션이 필요할때 트랜잭션이 없으면 발생
  트랜잭션 없이 엔터티를 변경할때 주로발생한다.
트랜잭션 롤백을 표시하는 예외는 심각한 예외이므로 복구해선 안 된다.

#### 트랜잭션 롤백을 표시하지 않는 예
- javax.persistence.NoResultException : Query.getSingleResult() 호출 시 결과가 하나도 없을 때 발생
- javax.persistence.NonUniqueResultException : Query.getSingleResult()호출 시 결과가 둘 이상일 때 발생
- javax.persistence.LockTimeoutException : 비관적 락에서 시간 초과 시 발생
- javax.persistence.QueryTimeoutException : 쿼리 실행 시간 초과 시 발생

### 트랜잭션 롤백 시 주의사항
트랜잭션을 롤백하는 것은 데이터베이스의 반영 사항만 롤백 하는 것이지 수정한 자바 객체까지 원 상태로 복구해주지는 않는다.      
예를 들어 엔티티를 조회해서 수정하는 중에 문제가 있어서 트랜잭션을 롤백하면 데이터베이스의 데이터는 원래대로 복구되지만 객체는 수정된 상태로 영속성 컨텍스트에 남아 있다.      
따라서 새로운 영속성 컨텍스트를 생성해서 사용하거나 EntityManager.clear()를 호출해서 영속성 컨텍스트를 초기화한 다음에 사용해야 한다.
## 엔터티 비교
영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다.       
이 1차 캐시 덕분에 변경 감지 기능도 동작하고, 이름 그대로 1차 캐시로 사용 되어서 데이터베이스를 통하지 않고 데이터를 바로 조회할 수도 있다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:appConfig.xml")
@Transactional
public class MemberServiceTest {

	@Test
	public void 회원가입() throws Exception {
		// Given
		Member member = new Member("kim");

		// When
		Long saveId = memberService.join(member);

		// Then
		Member findMember = memberRepository.findOne(saveId);
		assertTrue(member == findMember); // true 참조값 비교
	}
}
```
이것은 같은 트랜잭션 범위에 있으므로 같은 영속성 컨텍스트를 사용하기 때문이다. 따라서 영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족한다.
- 동일성: == 비교가 같다
- 동등성 : equals() 비교가 같다
- 데이터베이스 동등성 : @Id인 데이터베이스 식별자가 같다
### 프록시 심화 주제
프록시는 원본 엔티티를 상속받아서 만들어지므로 엔티티를 사용하는 클라이언트는 엔티티가 프록시인지 아니면 원본 엔티티인지 구분하지 않고 사용할 수 있다.      
이로 인해 예상하지 못한 문제들이 발생하기도 하는데, 어떤 문제가 발생하고 어떻게 해결해야 하는지 알아보자
#### 영속성 컨텍스트와 프록시
엔티티의 동등성을 비교하려면 비즈니스 키를 사용해서 equals() 메소드를 오버라이딩하고 비교하면 된다. 그런데 IDE나 외부 라이브러리를 사용해서 구현한 equals() 메소드로 엔티티를 비교할 때, 비교 대상이 원본 엔티티면 문제가 없지만 프록시면 문제가 발생할 수 있다.

```java
@Entity
public class Member {
  @Id
  private String id;
  private String name;

	...

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (this.getClass() != obj.getClass()) return false; // 1

    Member member = (Member) obj;

    if (this.name != null ? !this.name.equals(member.name) : member.name != null) //
      return false;

    return true;
  }
}
```
### 상속관계와 프록시
상속 관계를 프록시로 조회할 때 발생할 수 있는 문제점과 해결방안을 알아보자
해결방안
- JPQL로 대상 직접 조회
- 프록시 벗기기
- 기능을 위한 별도의 인터페이스 제공
비지터 패턴의 장점은 다음과 같다.    
  - 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.    
  - instanceof와 타입 캐스팅 없이 코드를 구현할 수 있다.    
  - 알고리즘과 객체 주고를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.    
단점은 다음과 같다.    
  - 너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어렵다.   
  - 객체 구조가 변경되면 모든 Visitor를 수정해야 한다.    

###성능 최적화
JPA로 애플리케이션을 개발할 때 발생하는 다양한 성능 문제와 해결 방안을 알아보자.
- N+1 문제
```java
- @Entity
public class Member {

	@Id @GeneratedValue
	private Long id;

	@OneToMany(mappedBy = "member", fetch = FetchType.EAGER)
	private List<Order> orders = new ArrayList<Order>();

	...
}
```
- 즉시 로딩과 N+1
  em.find() 메소드로 조회하면 즉시 로딩으로 설정한 주문정보도 함께 조회한다.
```java
em.find(Member.class, id);

// 결과값
        SELECT M.*, O.*
        FROM
        MEMBER M
        OUTER JOIN ORDERS O ON M.ID = O.MEMNBER_ID
```
#### N+1 문제를 피할 수 있는 해결방안
- 페치 조인 사용
- 하이버네이트 @BatchSize
- 하이버네이트 @Fetch