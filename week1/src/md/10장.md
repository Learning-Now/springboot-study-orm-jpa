# 객체지향 쿼리 언어
##10.1 JPA란 무엇인가?
####복잡하고 다양한 검색 조건을 사용해 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.

- 객체지향 쿼리 소개
- JPQL
- Criteria
- QueryDSL
- 네이티브 SQL
- 객체지향 쿼리 심화

## 10.1 객체지향 쿼리 소개 
### 객체지향 쿼리 소개란?

EntityManager.find() 메소드를 사용하면 식별자로 엔티티 조회가 가능하다.

- 식별자로 조회 EntityManger.find()
- 객체 그래프 탐색 (예: a.getB().getC())
이 둘은 가장 단순한 검색 방법이다.

하지만 이 기능만으로 애플리케이션을 개발하기 어렵다. 
데이터는 데이터베이스에 있으므로 SQL로 필요한 내용을 최대한 걸러서 조회해야한다 
하지만 ORM은 엔티티 객체를 대상으로 하는 방법이 필요하다.

<H3>JPQL</H3> 은 이를 해결하기 위해 만들어졌고 다음과 같은 특징이 있다.

- SQL을 추상화 해서 특정 데이터베이스 SQL에 의존하지 않음
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리이다.

JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다. 다음보는 식은 JPA가 
공식적으로 지원하는 기능이다.

- JPQL 
- Criteria 쿼리 : JPQL을 편하게 작성하도록 도와주는 API
- 네이티브 SQL : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.   
**다음은 JPA가 공식 지원하는 기능은 아니고 알아둘 가치가 있는것**
- QueryDSL : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음
- JDBC직접 사용 



###JPQL
JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.
문법은 SQL과 비슷하고 ANSI 표준 SQL이 제공하는 기능을 유사하게 지원한다.


## JPQL 사용 예시
```java
@Entity(name="Member")
public class Member{
    @Column(name="name")
    private String username;
}
```
을 JPQL을 사용하는 간단한 예제 이다.
```java
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = 
		em.createQuery(jpql, Member.class).getResultList();
```
##10.1.2 Criteria 쿼리 소개 
Criteria의 장점은 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.
JPQL은 오타가 있어도 컴파일은 성공하고 애플리케이션을 서버에 배포할 수 있다. 문제는 해당 쿼리가 실행되는 런타임 시점에 오류가 발생한다는 점이다. Criteria의 장점은 다음과 같다.
- 컴파일 시점에 오류를 발견할 수 있다.
- IDE를 사용하면 코드 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편하다
##QueryDSL 쿼리 소개
QueryDSL도 Criteria처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 코드 기반이면서 단순하고 사용하기 쉽다.   
QeuryDSL과 Criteria를 비교하면 Criteria는 너무 복잡하다.
##Native SQL 소개
JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 네이티브 SQL이라 한다.   
네이티브 SQL의 단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는것이다. 따라서 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.
```java
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList =
  em.createNativeQuery(sql, Member.class).getResultList();
```
##10.2 JPQL
####JPQL SELECT문
- 대소문자 구분 : 엔티티와 속성은 대소문자를 구분한다.
- 엔티티 이름 : JPQL에서 사용하는 객체는 클래스 명이 아니라 엔티티 명이다. 엔티티 명은 @Entity(name = "xxx")로 지정할 수 있다.
- 별칭은 필수 : JPQL은 별칭은 필수로 사용해야 한다.

### 파라미터 바인딩

JDBC는 위치 기준 파라미터 바인딩을 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원한다.

####이름 기준 파타미터 와 위치기준 파라미터
- 이름 기준 파라미터는 파라미터를 이름으로 구분하는 방법이다.   
이름 기준 파라미터는 앞에 : 를 사용한다
- 위치 기준 파라미터를 사용하려ㅓ면 ? 다음에 위치 값을 주면 된다.    
위치 값은 1부터 시작한다.   
**결론: 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다.**
###페치 조인
-페치(Fetch)조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능이다.     
이것은 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능인데 join fetch 명령어로 사용할 수 있다.

- JPA 표준 명세에 정의된 페치 조인 문법은 다음과 같다.    
페치 조인 ::= [LEFT [OUTER] | INNER ] JOIN FECTH 조인 경로

### 페치 조인과 일반 조인의 차이
- 페치 조인을 사용하지 않고 조인만 사용하면 어떻게 될까?

```java
select t
from Team t join t.members m
where t.name = '팀A'
```

```java
SELECT
  T.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A*'
```
- JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다.    
- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.     
**따라서 팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다.**
###페치 조인의 특징과 한계
- 페치 조인 대상에는 별칭을 줄 수 없다.    
JPA 표준에서는 지원하지 않지만 하이버네이트를 포함한 몇몇 구현체들은 페치 조인에 별칭을 지원한다.     
하지만 별칭을 잘못 사용하면 연관된 데이터 수가 달라져서 데이터 무결성이 깨질 수 있으므로
조심해서 사용해야한다.
- 둘 이상의 컬렉션의 페치 할 수 없다.
- 컬렉션을 페치 조인하면 페이징 API를 사용 할 수 없다.
## 경로 표현식

.(점)을 찍어 객체 그래프를 탐색하는 것.
```java
select m.username
from Member m  
        join m.team t 
        join m.orders o
where t.name='팀A' 
```
- 여기서 m.username, team, orders, name이 모두 경로 표현식을 사용한 예다.

###경로 표현식의 용어 정리
**경로 표현식을 이해하려면 우선 다음 용어들을 알아야 한다.**

- 상태필드: 단순히 값을 저장하기위한 필드(필드 or 프로퍼티)
- 연관필드: 연관관계를 위한 필드,임베디드 타입 포함(필드 or 프로퍼티)
  - 단일 값연관: @ManyToOne, @OneToOne 대상이 엔티티
  - 컬렉션 값연관: @OneToMany, @ManyToMany 대상이 컬렉션

**특징**

- 상태 필드 경로 : 경로 탐색의 끝이다. 더는 탐색할수없음
- 단일 값 연관 경로 : **묵시적으로 내부 조인**이 일어난다. 단일 값 연관 경로는 계속 탐색할 수 있다.
- 컬렉션 값 연관 경로 : 묵시적으로 내부 조인이 일어나며 더는 탐색 불가능

**경로 탐색을 사용한 묵시적 조인 주의사항**

- 항상 내부조인
- 컬렉션은 경로탐색의 끝 경로 탐색을 위해서는 별도의 별칭을 얻어야함
- 내부 조인보다는 명시적 조인을 사용하자    
**조인이 성능상 차지하는 부분은 아주 크다. 묵시적 조인은 조인이 일어나는 상황을 한눈에
파악하기 어렵다는 단점이 있다. 따라서 단순하고 성능에 이슈가 없으면 크게 문제가 안되지만    
성능이 중요하면 분석하기 쉽도록 묵시적 조인보다는 명시적 조인을 사용하자**

###Named 쿼리: 정적 쿼리 
JPQL 쿼리는 크게 동적 쿼리와 정적 쿼리로 나눌수 있다.
- 동적 쿼리 : em.createQuery("select ...") 처럼 JPQL을 문자로 완성해서 직접 넘기는 것을 동적 쿼리라 한다. 런타임에 특정 조건에 따라 JPQL을 동적으로 구성할 수 있다.
- 정적 쿼리 : 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용할 수 있는데 이를 Named 쿼리라 한다.    
**@NamedQuery.query에 사용할 쿼리를 입력한다.**
```java
List<Member> resultList = em.createNamedQuery("Member.findByUsername", Member.class)
	.setParameter("username", "회원1")
	.getResultList();
```

###Criteria 
####Criteria란
Criteria 쿼리는 JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API다.    
Criteria를 사용하면 문자가 아닌 코드로 JPQL을 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있고 문자 기반의 JPQL보다 동적 쿼리를 안전하게 생성할 수 있는 장점이 있다.
1. Criteria 쿼리를 생성하려면 먼저 Criteria 빌더(CriteriaBuilder)를 얻어야 한다. Criteria 빌더는 EntityManager나 EntityManagerFactory에서 얻을 수 있다.
2. Criteria 쿼리 빌더에서 Criteria 쿼리(CriteriaQuery)를 생성한다. 이때 반환 타입을 지정할 수 있다.
3. FROM 절을 생성한다. 반환된 값 m은 Criteria에서 사용하는 특별한 별칭이다. m을 조회의 시작점이라는 의미로 쿼리 루트(Root)라 한다.
4. SELECT 절을 생성한다
####조인
조인은 join() 메소드와 joinType 클래스를 사용한다.
####튜플
Criteria는 Map과 비슷한 튜플이라는 특별한 반환 객체를 제공한다.
####Criteria 메타 모델 API
Criteria는 코드 기반이므로 컴파일 시점에 오류를 발견할 수 있다. 하지만 m.get("age")에서 age는 문자다. 'age'대신에 실수로 'ageaaa' 이렇게 잘못 적어도 컴파일 시점에 에러를 발견하지 못한다.     
따라서 완전한 코드 기반이라 할 수 없다. 이런 부분까지 코드로 작성하려면 메타 모델 API를 사용하면 된다.
###QueryDSL
Criteria의 장점은 문법 오류를 컴파일 단계에서 잡을 수 있고 IDe 자동완성 기능의 도움을 받을 수 있는 등 여러 가지 장점이 있다.    
Criteria의 가장 큰 단점은 너무 복잡하고 어렵다는 것이다. QueryDSL도 Criteria처럼 JPQL 빌더 역할을 하는데 JPA Criteria를 대체할 수 있다.
**<H3>검색 조건 쿼리</H3>**
쿼리 작성이 끝나고 결과 조회 메소드를 호출하면 실제 데이터베이스를 조회한다.      
대표적인 결과 조회 메소드는 다음과 같다.    
+ uniqueResult() : 조회 결과가 한 건일 때 사용한다. 조회 결과가 없으면 null을 반환하고 결과가 하나 이상이면 NonUniqueResultException 예외가 발생한다.   
+ singleResult() : uniqueResult()와 같지만 결과가 하나 이상이면 처음 데이터를 반환한다.                    
+ list() : 결과가 하나 이상일 때 사용한다. 결과가 없으면 빈 컬렉션을 반환한다.
###네이티브 SQL
JPQL은 표준 SQL이 지원하는 대부분의 문법과 SQL 함수들을 지원하지만 특정 데이터베이스에 종속적인 기능은 지원하지 않는다.    
- 특정 데이터베이스만 지원하는 함수, 문법, SQL 쿼리 힌트
- 인라인 뷰, UNION, INTERSECT
- 스토어드 프로시저
이는 종속적인 기능을 지원하는 방법이다.
**가장 중요한 점은 네이티브 SQL로 SQL만 직접 사용할 뿐이지 나머지는 JPQL을 사용할 때와 같다. 조회한 엔티티도 영속성 컨텍스트에서 관리된다.**